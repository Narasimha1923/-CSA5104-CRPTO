import re
2	+
3	+
def egcd(a,b):
4	+
    if b==0:return(a,1,0)
5	+
    g,x1,y1=egcd(b,a%b)
6	+
    return(g,y1,x1-(a//b)*y1)
7	+
def modinv(a,m):
8	+
    g,x,_=egcd(a,m)
9	+
    return x%m if g==1 else None
10	+
def det2(M):
11	+
    return (M[0][0]*M[1][1]-M[0][1]*M[1][0])%26
12	+
def inv2(M):
13	+
    d=det2(M);di=modinv(d,26)
14	+
    if di is None:return None
15	+
    adj=[[M[1][1]%26,(-M[0][1])%26],[(-M[1][0])%26,M[0][0]%26]]
16	+
    return [[(di*adj[i][j])%26 for j in range(2)]for i in range(2)]
17	+
def mat_mul(A,B):
18	+
    return [[sum(A[i][k]*B[k][j]for k in range(2))%26 for j in range(len(B[0]))]for i in range(2)]
19	+
20	+
pt=re.sub('[^a-z]','',input("Enter plaintext: ").lower())
21	+
ct=re.sub('[^a-z]','',input("Enter ciphertext: ").lower())
22	+
P=[[ord(pt[0])-97,ord(pt[2])-97],[ord(pt[1])-97,ord(pt[3])-97]]
23	+
C=[[ord(ct[0])-97,ord(ct[2])-97],[ord(ct[1])-97,ord(ct[3])-97]]
24	+
P_inv=inv2(P)
25	+
if P_inv is None:exit("Plaintext matrix not invertible")
26	+
K=mat_mul(C,P_inv)
27	+
print("Recovered Key Matrix:")
28	+
for r in K:print(r)
